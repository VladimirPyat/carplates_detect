БИБЛИОТЕКА ДЛЯ НАРЕЗКИ ВИДЕО
Файл cam_video_parse.py
Данный код помогает искать на видео различные объекты при помощи yolov8 Найденные объекты сохраняются в файлах формата jpg

до начала работы скрипта необходимо указать параметры:

SOURCE_DIR - путь для поиска видео файлов RESULT_DIR - путь для сохранения файлов изображений (при отсутствии создаст автоматически)
CAM_AREAS - словарь, содержащий имя камеры в качестве ключа и кортеж из координат области детекции в качестве значений список координат имеет вид x_percent, y_percent, w_percent, h_percent - координата х у левого верхнего угла, а также ширина и высота области в процентах от размера изображения задается опытным путем, с учетом расположения камер
CLASSES_TO_DETECT - список номеров классов объектов yolov8 которые нужно обнаружить на видео
FRAMES_SKIP - для ускорения обработки и облегчения получившегося набора изображений, можно обнаруживать объекты не на всех кадрах, а пропускать какое-то количество

для запуска скрипта нужно выполнить функцию <i>video_path_proceed()</i> данная функция ищет в директории SOURCE_DIR файлы с нужным расширением (по умолчанию mp4) и сохраняет результат в RESULT_DIR
также можно указать конкретный файл <i>video_proceed(video_filename)</i>
после обработки каждого видеофайла в консоль выводится количество сохраненных изображений и затраченное время

для реализации данного метода можно запустить детектирование объектов с параметром predictions = model.predict(save_txt=True) координаты bounding_box сохраняются в текстовом файле, далее можно их обработать

---

upd v2.0

ДОБАВЛЕНА ПОСТ ОБРАБОТКА ФАЙЛОВ
Ранее после обработки видео получались полные кадры. теперь мы обрабатываем их и обрезаем по bounding box 

Для обработки одного файла применяем функцию <i>image_proceed()</i>

show=True - удобно использовать с данным параметром при настройке зоны обнаружения. 
Показывает синим цветом зону обнаружения
bounding box отрисовываются стандартными средствами yolo. по умолчанию показывает имя класса и вероятность его детекции
Если bounding box левым нижним углом попадает в зону обнаружения - он отмечается зеленой точкой. Иначе точка красная
save=True - по умолчанию в случае обнаружения объекта в указанной зоне (с помощью is_in_detect_zone()), изображение объекта, обрезанное по bounding box, сохраняется.
Для настройки зоны обнаружения сохранение можно отключить, save=False

Для обработки изображений в папке используется <i>images_path_proceed()</i> с указание пути 
Обработанные сохраняются в POST_RESULT_DIR 

Реализована проверка движения объекта при обработке видео is_obj_motion()
Добавлен параметр MOTION_TRES. Это минимальное расстояние, на которое должен переместиться bounding box между соседними кадрами, чтобы автомобиль не считался неподвижным.
Расстояние измеряется в процентах от длины диагонали изображения, 1=100%
Кадр из видео сохраняется в том случае, когда на нем обнаружен целевой объект и когда он движется 
 
ОБНОВЛЕНЫ ПОЛИГОНЫ ДЛЯ КАМЕР
зоны обнаружения уменьшены. старый вариант закомментировал
оставлено для совместимости с ранее нарезанными изображениями
в новых разработках можно сразу сохранять уменьшенные изображения

ДОБАВЛЕНА БИБЛИОТЕКА ДЕДУБЛИКАТОР
Файл doubles_check.py
Используется для обработки _обрезанных_ изображений.  
Использует модель ResNet50 для поиска уникальных признаков изображений
Далее сортирует изображения по дате создания и сравнивает их _попарно_ i с i+1 
Такой метод применен, поскольку мы ранее получили изображения из последовательных кадров видео
Далее производится вычисление косинусного расстояния между векторами признаков, на основе чего находится вероятность того, что объекты на двух изображениях одинаковые
1 - 100% одинаковые изображения


Запуск дедубликатора функцией <i>compare_files_recursive()</i>
Задаются пути для исходных файлов, для сохранения результата и значение порога идентичности в % (1=100%)
Рекурсивно обходит все вложенные папки
Первое изображение в папке сохраняется, потом сравнивается со вторым. 
Если изображения одинаковы с вероятностью выше установленного порога - второе также сохраняется, далее переход на следующий шаг.


upd v3.0

### Добавлена функция нормализации датасета dataset_strat.py

Идея в том, чтобы выровнять количество экземпляров в каждом классе датасета в том случае, когда на каждом изображении 
присутствует несколько классов (как например символы на автономере).

для обработки данных датасета создан класс _class DatasetDF_ 
для создания экземпляра класса на основе датасета используется функция _pd_from_yolo(folder_path)_
датасет должен содержать изображения и текстовые метки в формате yolo без разбивки на train/test/val

для получения статистики используется метод _calculate_statistics()_
содержит два аргумента
print_stat - вывод статистики в консоль (кол-во классов, кол-во экземпляров, среднее и т.п.)
show_hist - показ гистограммы распределения по классам

метод _delete_for_normalize(target_delta=0.3, min_class_count=1)_
формирует список файлов, в случае исключения которых улучшится баланс классов
содержит парамеры
target_delta - целевое максимальное отклонение от среднего количества для каждого класса
min_class_count - минимальное количество экземпляров в классе

Принцип работы алгоритма следующий:
Для каждого класса формируется вес на основании количества экземпляров в датасете
Если количество меньше среднего - вес отрицательный
Вес для каждого файла является суммой весов по всем представленным классам

Файлы сортируются по весу в порядке убывания.
Алгоритм проходит по списку файлов. Фиксирует те классы, количество экземпляров в которых в пределах нормы
Далее убирает по одному файлы с максимальным весом. 
Если исключение файла не приводит к нарушению баланса в уже нормализованных классах - файл добавляется в список,
а алгоритм переходит к следующему файлу. В случае изменения баланса в нормализованных классах, 
файл возвращается в датасет.

ИТОГ эффективность работы алгоритма не подтвердилась экспериментально
Существенного улучшения баланса достичь не удалось
Возможно задачу удастся решить путем усложнения функции подсчета весов, усложнения самого алгоритма 
выбора нужных файлов. 

### Добавлена функция проверки разметки датасета в CVAT CVAT_labels_check.ipynb
Некоторые файлы датасета с автономерами содержали номер в своем названии
Для упрощения проверки разметки написан код в формате ноутбука google colab,
который проверяет в xml файле CVAT соответствие имени файла и разметки
Данный код не меняет разметку, а лишь указывает на несоответствие, поскольку имя файла также может иметь ошибки

ВСЕ ФАЙЛЫ ДЛЯ РАБОТЫ С ДАТАСЕТАМИ ПЕРЕНЕСЕНЫ В dataset_prepare

### Добавлена папка plates recognize, которая содержит два варианта приложений
1. модель keras, обученная на датасете символов Chars74K
2. модель yolo, обученная на датасете символов с автономеров

задачу распознавания номеров можно разделить на три ступени:
- детекция автомобилей. тут же происходит классификация - обычный автомобиль либо спецслужбы
- детекция автомобильного номера
- чтение символод на номере


Для ПЕРВОЙ используется yolov8, обученная на датасете спецтранспорта
Для ВТОРОЙ  используется yolov8, обученная на датасете рамок автономеров (obb)
Ниже описаны два типа моделей, относящиеся к ТРЕТЬЕЙ ступени

<b>модель keras</b> 
Проверялась гипотеза распознавания символов при помощи нейросети обученной на датасете различных символов
Сначала производилась предобработка изображения с номером
Детекция символов выполнялась при помощи библиотеки opencv (определение контуров)
Далее контуры фильтровались по размеру (отметали слишком мелкие и слишком крупные)
После этого каждый символ передавался на распознавание в модель keras
Данная методика на старте давала крайне низкую точность. 
Точно обнаруживалось примерно 60% всех символов на номере, точность распознавания символов получалась менее 50%
В дальнейшем было принято решение отказаться от данной гипотезы

<b>модель yolo</b> 
Данная модель обучалась более чем на 10 тысяч изображений
Модуль включает в себя классы для работы с различными типами ограничивающих рамок, включая обычные и ориентированные ограничивающие рамки.

## Классы

### PredictProcess

Базовый класс для обработки предсказаний. Этот класс содержит общую функциональность для работы с моделью  и предоставляет базовые методы, которые могут быть переопределены в дочерних классах.

### PredictProcessObb(PredictProcess)

Этот класс наследует `PredictProcess` и предназначен для работы с ориентированными ограничивающими рамками (Oriented Bounding Boxes - OBB).

#### Методы

- **`_create_boxes()`**: 
  Создает уникальные идентификаторы для каждой ограничивающей рамки. Если координаты ограничивающей рамки совпадают с уже существующими, добавляется небольшая случайная дельта, чтобы сделать ключи уникальными

- **`get_image_by_box(box_id=None, scale=2)`**: 
  Извлекает часть изображения по заданным координатам ограничивающей рамки. Позволяет поворачивать изображение в соответствии с углом ориентации ограничивающей рамки и изменять его размер.

### PredictProcessBox(PredictProcess)

Этот класс также наследует `PredictProcess`, но предназначен для работы с обычными ограничивающими рамками (Bounding Boxes). 

### `_create_boxes()`

Создает боксы аналогично одноименному методу PredictProcessBB. Разница лишь в типе боксов

### `get_box_in_zone(x_, y_, w_, h_)`

Метод проверяет, находится ли бокс в заданной зоне, определяемой координатами (x_, y_) и размерами (w_, h_). Возвращает идентификатор бокса, если он находится в зоне, и `None` в противном случае.

### `get_image_by_box(box_id)`

Этот метод извлекает изображение, соответствующее определенному боксу, используя его идентификатор. Возвращает часть оригинального изображения, ограниченную рамками бокса.

### `get_box_conf(box_id)`

Возвращает уверенность (confidence score) для бокса, идентифицированного по `box_id`. 

### `get_text()`

Метод извлекает распознанный текст из боксов, основываясь на координатах символов. Он разделяет символы на верхний и нижний ряды, сортирует их по координатам и объединяет в строку для получения окончательного текста.

### `is_common_car(box_id)`
### `is_special_car(box_id)`

Проверяют, является ли автомобиль обычным или специальным

Данные классы используются в приложении распознавания номеров

upd v4.0
### Добавлено приложение streamlit для распознавания номеров
Пользователи могут загружать видеофайлы, настраивать параметры детекции и просматривать результаты

## Основной функционал

### Загружаемые данные
- **Загрузка видеофайла**: Пользователь может загрузить видеофайлы в форматах MP4, AVI или MOV через боковую панель приложения.

### Пользовательские настройки
- **Координаты зоны детекции**:
  - Положение X (0-100%)
  - Положение Y (0-100%)
  - Ширина (0-100%)
  - Высота (0-100%)
  
  Эти параметры позволяют пользователю задать область, в которой будет происходить детекция объектов. Область задается в процентах от размера изображения

- **Параметры отображения**:
  - Чекбокс для показа времени детекции.
  - Чекбокс для выделения обнаруженных объектов.

- **Ввод текста**: Пользователь может ввести искомый номер автомобиля. При обнаружении авто с данным номером, а также при обнаружении машин спецслужб, будет выводиться сообщение "Доступ разрешен"

### Управление воспроизведением
- **Кнопка "Перезапустить видео"**: Позволяет пользователю перезапустить воспроизведение видео с самого начала.
- **Чекбокс "Воспроизведение видео"**: Позволяет пользователю включать или останавливать воспроизведение видео.

### Обработка обнаруженных автомобилей
- При обнаружении автомобиля в заданной зоне:
  - Отображается изображение автомобиля, определяемое с помощью класса `PredictProcessBox`.
  - Классифицируется тип автомобиля (обычный или спецтранспорт).
  - Если это обычный автомобиль, происходит распознавание номера.
    - Используется класс `PredictProcessObb` для распознавания рамки номера.
    - Если номер распознан, выводится текст распознанного номера и время распознавания.
    - Если номер совпадает с введенным пользователем, доступ разрешается, иначе — запрещается.
  
### Вывод информации
Выделяется несколько фреймов, в которых отображается текст и изображения/видео
- **Основной фрейм**: Тут отображается видео с наложенной областью детекции. Под видео появляется сообщение о допуске / недопуске транспортного средства
- **Область детекции**: Тут отображается изображение автомобиля, включая текст с описанием класса автомобиля и время обработки.
- **Область номера**: Тут отображается изображение номера автомобиля, а также распознанный текст и время распознавания.


- Результаты обработки записываются в лог в формате CSV, что позволяет отслеживать события, связанные с обнаружением и распознаванием автомобилей.

